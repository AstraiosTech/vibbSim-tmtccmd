import enum
from collections import deque
from dataclasses import dataclass
from typing import Dict, List

from spacepackets.cfdp import PduType, ChecksumTypes, TransmissionModes
from spacepackets.cfdp.pdu import DirectiveType, AbstractFileDirectiveBase, MetadataPdu
from spacepackets.cfdp.pdu.helper import GenericPduPacket, PduHolder
from tmtccmd.cfdp import RemoteEntityCfg
from tmtccmd.cfdp.defs import CfdpStates
from tmtccmd.cfdp.handler.defs import FileParams


class TransactionStep(enum.Enum):
    IDLE = 0
    # Metadata was received
    TRANSACTION_START = 1
    CRC_PROCEDURE = 2
    RECEIVING_FILE_DATA = 3
    # EOF was received. Perform checksum verification and notice of completion
    TRANSFER_COMPLETION = 4
    SEINDING_FINISHED_PDU = 5


@dataclass
class DestStateWrapper:
    state: CfdpStates = CfdpStates.IDLE
    transaction: TransactionStep = TransactionStep.IDLE
    packet_ready: bool = False


class FsmResult:
    def __init__(self, states: DestStateWrapper, pdu_holder: PduHolder):
        self.states = states
        self.pdu_holder = pdu_holder


class DestHandler:
    def __init__(self, cfg: RemoteEntityCfg):
        self.cfg = cfg
        self.states = DestStateWrapper()
        self._pdu_holder = PduHolder(None)
        self._checksum_type = ChecksumTypes.NULL_CHECKSUM
        self._closure_requested = False
        self._fp = FileParams()
        self._file_directives_dict: Dict[
            DirectiveType, List[AbstractFileDirectiveBase]
        ] = dict()
        self._file_data_deque = deque()

    def _start_transaction(self, metadata_pdu: MetadataPdu) -> bool:
        if self.states.state != CfdpStates.IDLE:
            return False
        if metadata_pdu.pdu_header.trans_mode == TransmissionModes.UNACKNOWLEDGED:
            self.states.state = CfdpStates.BUSY_CLASS_1_NACKED
        elif metadata_pdu.pdu_header.trans_mode == TransmissionModes.ACKNOWLEDGED:
            self.states.state = CfdpStates.BUSY_CLASS_2_ACKED
        self._checksum_type = metadata_pdu.checksum_type
        self._closure_requested = metadata_pdu.closure_requested
        self._fp.size = metadata_pdu.file_size
        return True

    def state_machine(self) -> FsmResult:
        if self.states.state == CfdpStates.IDLE:
            transaction_was_started = False
            if DirectiveType.METADATA_PDU in self._file_directives_dict:
                for pdu in self._file_directives_dict.get(DirectiveType.METADATA_PDU):
                    metadata_pdu = PduHolder(pdu).to_metadata_pdu()
                    transaction_was_started = self._start_transaction(metadata_pdu)
                    if transaction_was_started:
                        break
            if not transaction_was_started:
                return FsmResult(self.states, self._pdu_holder)
        elif self.states.state == CfdpStates.BUSY_CLASS_1_NACKED:
            pass
        return FsmResult(self.states, self._pdu_holder)

    def pass_packet(self, packet: GenericPduPacket):
        # TODO: Sanity checks
        if packet.pdu_type == PduType.FILE_DATA:
            self._file_data_deque.append(packet)
        else:
            if packet.directive_type in self._file_directives_dict:
                self._file_directives_dict.get(packet.directive_type).append(packet)
            else:
                self._file_directives_dict.update({packet.directive_type: [packet]})
        pass

    def confirm_packet_sent_advance_fsm(self):
        """Helper method which performs both :py:meth:`confirm_packet_sent` and
        :py:meth:`advance_fsm`
        """
        self.confirm_packet_sent()
        self.advance_fsm()

    def confirm_packet_sent(self):
        """Confirm that a packet generated by the :py:meth:`operation` was sent successfully"""
        self.states.packet_ready = False

    def advance_fsm(self):
        pass
