from __future__ import annotations
import enum
from collections import deque
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Deque, cast

from spacepackets.cfdp import PduType, ChecksumTypes, TransmissionModes
from spacepackets.cfdp.pdu import (
    DirectiveType,
    AbstractFileDirectiveBase,
    MetadataPdu,
    FileDataPdu,
)
from spacepackets.cfdp.pdu.helper import GenericPduPacket, PduHolder
from tmtccmd.cfdp import RemoteEntityCfg, CfdpUserBase
from tmtccmd.cfdp.defs import CfdpStates
from tmtccmd.cfdp.handler.defs import FileParamsBase


@dataclass
class DestFileParams(FileParamsBase):
    file_name: Path

    @classmethod
    def empty(cls) -> DestFileParams:
        return cls(offset=0, segment_len=0, crc32=bytes(), size=0, file_name=Path())

    def reset(self):
        super().reset()
        self.file_name = Path()


class TransactionStep(enum.Enum):
    IDLE = 0
    # Metadata was received
    TRANSACTION_START = 1
    RECEIVING_FILE_DATA = 2
    SENDING_ACK_PDU = 3
    # File transfer complete. Perform checksum verification and notice of completion
    TRANSFER_COMPLETION = 4
    SENDING_FINISHED_PDU = 5


@dataclass
class DestStateWrapper:
    state: CfdpStates = CfdpStates.IDLE
    transaction: TransactionStep = TransactionStep.IDLE
    packet_ready: bool = False


class FsmResult:
    def __init__(self, states: DestStateWrapper, pdu_holder: PduHolder):
        self.states = states
        self.pdu_holder = pdu_holder


class DestHandler:
    def __init__(self, cfg: RemoteEntityCfg, user: CfdpUserBase):
        self.cfg = cfg
        self.states = DestStateWrapper()
        self.user = user
        self._pdu_holder = PduHolder(None)
        self._checksum_type = ChecksumTypes.NULL_CHECKSUM
        self._closure_requested = False
        self._fp = DestFileParams.empty()
        self._file_directives_dict: Dict[
            DirectiveType, List[AbstractFileDirectiveBase]
        ] = dict()
        self._file_data_deque: Deque[FileDataPdu] = deque()

    def _start_transaction(self, metadata_pdu: MetadataPdu) -> bool:
        if self.states.state != CfdpStates.IDLE:
            return False
        self.states.transaction = TransactionStep.TRANSACTION_START
        if metadata_pdu.pdu_header.trans_mode == TransmissionModes.UNACKNOWLEDGED:
            self.states.state = CfdpStates.BUSY_CLASS_1_NACKED
        elif metadata_pdu.pdu_header.trans_mode == TransmissionModes.ACKNOWLEDGED:
            self.states.state = CfdpStates.BUSY_CLASS_2_ACKED
        self._checksum_type = metadata_pdu.checksum_type
        self._closure_requested = metadata_pdu.closure_requested
        self._fp.file_name = Path(metadata_pdu.dest_file_name)
        self._fp.size = metadata_pdu.file_size
        self.states.transaction = TransactionStep.RECEIVING_FILE_DATA
        return True

    def state_machine(self) -> FsmResult:
        if self.states.state == CfdpStates.IDLE:
            transaction_was_started = False
            if DirectiveType.METADATA_PDU in self._file_directives_dict:
                for pdu in self._file_directives_dict.get(DirectiveType.METADATA_PDU):
                    metadata_pdu = PduHolder(pdu).to_metadata_pdu()
                    transaction_was_started = self._start_transaction(metadata_pdu)
                    if transaction_was_started:
                        break
            if not transaction_was_started:
                return FsmResult(self.states, self._pdu_holder)
        elif self.states.state == CfdpStates.BUSY_CLASS_1_NACKED:
            if self.states.transaction == TransactionStep.RECEIVING_FILE_DATA:
                # TODO: Sequence count check
                for file_data_pdu in self._file_data_deque:
                    data = file_data_pdu.file_data
                    offset = file_data_pdu.offset
                    self.user.vfs.write_data(self._fp.file_name, data, offset)
            if self.states.transaction == TransactionStep.TRANSFER_COMPLETION:
                pass
            pass
        return FsmResult(self.states, self._pdu_holder)

    def pass_packet(self, packet: GenericPduPacket):
        # TODO: Sanity checks
        if packet.pdu_type == PduType.FILE_DATA:
            self._file_data_deque.append(cast(FileDataPdu, packet))
        else:
            if packet.directive_type in self._file_directives_dict:
                self._file_directives_dict.get(packet.directive_type).append(packet)
            else:
                self._file_directives_dict.update({packet.directive_type: [packet]})
        pass

    def confirm_packet_sent_advance_fsm(self):
        """Helper method which performs both :py:meth:`confirm_packet_sent` and
        :py:meth:`advance_fsm`
        """
        self.confirm_packet_sent()
        self.advance_fsm()

    def confirm_packet_sent(self):
        """Confirm that a packet generated by the :py:meth:`operation` was sent successfully"""
        self.states.packet_ready = False

    def advance_fsm(self):
        pass
