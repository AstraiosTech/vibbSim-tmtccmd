import argparse
import collections.abc
import pprint
from typing import Union, List, Dict

from tmtccmd.utility.logger import get_logger
from tmtccmd.utility.conf_util import check_args_in_dict, print_core_globals
from tmtccmd.ecss.conf import PusVersion, set_default_apid, set_pus_tc_version, set_pus_tm_version
from tmtccmd.core.globals_manager import update_global, get_global
from tmtccmd.config.definitions import CoreGlobalIds, CoreModeList, CoreServiceList, \
    CoreModeStrings, CoreComInterfacesDict, CoreComInterfaces
from tmtccmd.com_if.com_if_utilities import determine_com_if
from tmtccmd.config.com_if import default_serial_cfg_setup, default_tcpip_udp_cfg_setup
from tmtccmd.config.definitions import DEBUG_MODE, ServiceOpCodeDictT, OpCodeDictKeys

LOGGER = get_logger()
SERVICE_OP_CODE_DICT = dict()


def get_global_apid() -> int:
    return get_global(CoreGlobalIds.APID)


def set_json_cfg_path(json_cfg_path: str):
    update_global(CoreGlobalIds.JSON_CFG_PATH, json_cfg_path)


def set_default_globals_pre_args_parsing(
        gui: bool, apid: int, pus_tc_version: PusVersion = PusVersion.PUS_C,
        pus_tm_version: PusVersion = PusVersion.PUS_C,
        com_if_id: str = CoreComInterfaces.DUMMY.value, display_mode="long",
        tm_timeout: float = 4.0, print_to_file: bool = True, tc_send_timeout_factor: float = 2.0
):
    update_global(CoreGlobalIds.APID, apid)
    set_default_apid(default_apid=apid)
    set_pus_tc_version(pus_tc_version)
    set_pus_tm_version(pus_tm_version)
    update_global(CoreGlobalIds.COM_IF, com_if_id)
    update_global(CoreGlobalIds.TC_SEND_TIMEOUT_FACTOR, tc_send_timeout_factor)
    update_global(CoreGlobalIds.TM_TIMEOUT, tm_timeout)
    update_global(CoreGlobalIds.DISPLAY_MODE, display_mode)
    update_global(CoreGlobalIds.PRINT_TO_FILE, print_to_file)
    update_global(CoreGlobalIds.SERIAL_CONFIG, dict())
    update_global(CoreGlobalIds.ETHERNET_CONFIG, dict())
    pp = pprint.PrettyPrinter()
    update_global(CoreGlobalIds.PRETTY_PRINTER, pp)
    update_global(CoreGlobalIds.TM_LISTENER_HANDLE, None)
    update_global(CoreGlobalIds.COM_INTERFACE_HANDLE, None)
    update_global(CoreGlobalIds.TMTC_PRINTER_HANDLE, None)
    update_global(CoreGlobalIds.PRINT_RAW_TM, False)
    update_global(CoreGlobalIds.USE_LISTENER_AFTER_OP, True)
    update_global(CoreGlobalIds.RESEND_TC, False)
    update_global(CoreGlobalIds.OP_CODE, "0")
    update_global(CoreGlobalIds.MODE, CoreModeList.LISTENER_MODE)


def set_default_globals_post_args_parsing(
        args: argparse.Namespace,
        json_cfg_path: str,
        custom_modes_list: Union[None, List[Union[collections.abc.Iterable, dict]]] = None,
        custom_services_list: Union[None, List[Union[collections.abc.Iterable, dict]]] = None,
        custom_com_if_dict: Dict[str, any] = None
):
    """
    This function takes the argument namespace as a parameter and determines
    a set of globals from the parsed arguments.
    If custom dictionaries are specified, the developer should take care of specifying
    integers as keys and the string representation of the command line argument as value.
    This will be used for internalization.
    :param args:                    Namespace generated by parsing command line arguments.
    :param json_cfg_path:
    :param custom_modes_list:       List of collections or dictionaries containing custom modes
    :param custom_services_list:    List of collections or dictionaries containing custom services
    :param custom_com_if_dict:    List of collections or dictionaries containing customcommunication interfaces
    :return:
    """

    # Determine communication interface from arguments. Must be contained in core modes list
    try:
        mode_param = args.mode
    except AttributeError:
        LOGGER.warning("Passed namespace does not contain the mode (-m) argument")
        mode_param = CoreModeList.LISTENER_MODE
    mode_param = check_and_set_core_mode_arg(
        mode_arg=mode_param, custom_modes_list=custom_modes_list
    )

    # Determine communication interface from arguments. Must be contained in core comIF list
    try:
        com_if_key = str(args.com_if)
    except AttributeError:
        LOGGER.warning("No communication interface specified")
        LOGGER.warning("Trying to set from existing configuration..")
        com_if_key = determine_com_if(com_if_dict=all_com_ifs, json_cfg_path=json_cfg_path)
    if com_if_key == CoreComInterfaces.UNSPECIFIED.value:
        all_com_ifs = CoreComInterfacesDict
        if custom_com_if_dict is not None:
            all_com_ifs = CoreComInterfacesDict.update(custom_com_if_dict)
        com_if_key = determine_com_if(com_if_dict=all_com_ifs, json_cfg_path=json_cfg_path)
    update_global(CoreGlobalIds.COM_IF, com_if_key)

    display_mode_param = "long"
    if args.short_display_mode is not None:
        if args.short_display_mode:
            display_mode_param = "short"
        else:
            display_mode_param = "long"
    update_global(CoreGlobalIds.DISPLAY_MODE, display_mode_param)

    try:
        service_param = args.service
    except AttributeError:
        LOGGER.warning("Passed namespace does not contain the service (-s) argument. Setting test service ID (17)")
        service_param = CoreServiceList.SERVICE_17.value
    update_global(CoreGlobalIds.CURRENT_SERVICE, service_param)
    # Not used for now
    """
    check_and_set_core_service_arg(
        service_arg=service_param, custom_service_list=custom_services_list
    )
    """

    if args.op_code is None:
        op_code = 0
    else:
        op_code = str(args.op_code).lower()
    update_global(CoreGlobalIds.OP_CODE, op_code)

    try:
        check_and_set_other_args(args=args)
    except AttributeError:
        LOGGER.exception("Passed arguments are missing components.")

    # For a serial communication interface, there are some configuration values like
    # baud rate and serial port which need to be set once but are expected to stay
    # the same for a given machine. Therefore, we use a JSON file to store and extract
    # those values
    if com_if_key == CoreComInterfaces.SERIAL_DLE.value or \
            com_if_key == CoreComInterfaces.SERIAL_FIXED_FRAME.value or \
            com_if_key == CoreComInterfaces.SERIAL_QEMU.value:
        default_serial_cfg_setup(com_if_key=com_if_key, json_cfg_path=json_cfg_path)

    # Same as above, but for server address and server port
    if com_if_key == CoreComInterfaces.TCPIP_UDP:
        # TODO: Port and IP address can also be passed as CLI parameters.
        #      Use them here if applicable?
        default_tcpip_udp_cfg_setup(json_cfg_path=json_cfg_path)
    if DEBUG_MODE:
        print_core_globals()


def check_and_set_other_args(args):
    if args.listener is not None:
        update_global(CoreGlobalIds.USE_LISTENER_AFTER_OP, args.listener)
    if args.tm_timeout is not None:
        update_global(CoreGlobalIds.TM_TIMEOUT, args.tm_timeout)
    if args.print_hk is not None:
        update_global(CoreGlobalIds.PRINT_HK, args.print_hk)
    if args.print_tm is not None:
        update_global(CoreGlobalIds.PRINT_TM, args.print_tm)
    if args.raw_data_print is not None:
        update_global(CoreGlobalIds.PRINT_RAW_TM, args.raw_data_print)
    if args.print_log is not None:
        update_global(CoreGlobalIds.PRINT_TO_FILE, args.print_log)
    if args.resend_tc is not None:
        update_global(CoreGlobalIds.RESEND_TC, args.resend_tc)
    update_global(CoreGlobalIds.TC_SEND_TIMEOUT_FACTOR, 3)


def check_and_set_core_mode_arg(
        mode_arg: any,
        custom_modes_list: Union[None, List[Union[dict, collections.abc.Iterable]]] = None
) -> int:
    """
    Checks whether the mode argument is contained inside the core mode list integer enumeration
    or a custom mode list integer which can be passed optionally.
    This function will set the single command mode as the global mode parameter if the passed mode
    is not found in either enumerations.
    :param mode_arg:
    :param custom_modes_list:
    :return:
    """
    in_enum, mode_value = check_args_in_dict(
        param=mode_arg, iterable=CoreModeList, warning_hint="mode integers"
    )
    if not in_enum:
        in_enum, mode_value = check_args_in_dict(
            param=mode_arg, iterable=CoreModeStrings, warning_hint="mode strings"
        )
    if in_enum:
        update_global(CoreGlobalIds.MODE, mode_value)
        return mode_value

    mode_arg_invalid = False
    if custom_modes_list is not None:
        for custom_mode_entry in custom_modes_list:
            in_enum, mode_value = check_args_in_dict(
                param=mode_arg, iterable=custom_mode_entry, warning_hint="custom mode"
            )
            if in_enum:
                break
        if not in_enum:
            mode_arg_invalid = True
    else:
        mode_arg_invalid = True

    if mode_arg_invalid:
        LOGGER.warning(f"Passed mode argument might be invalid, "
                       f"setting to {CoreModeList.SINGLE_CMD_MODE}")
        mode_value = CoreModeList.SINGLE_CMD_MODE
    update_global(CoreGlobalIds.MODE, mode_value)


def check_and_set_core_service_arg(
        service_arg: any, custom_service_list: collections.abc.Iterable = None
):
    in_enum, service_value = check_args_in_dict(
        param=service_arg, iterable=CoreServiceList, warning_hint="service"
    )
    if in_enum:
        update_global(CoreGlobalIds.CURRENT_SERVICE, service_value)
        return

    service_arg_invalid = False
    if custom_service_list is not None:
        for custom_services_entry in custom_service_list:
            in_enum, service_value = check_args_in_dict(
                param=service_arg, iterable=custom_services_entry, warning_hint="custom mode"
            )
            if in_enum:
                break
        if not in_enum:
            service_arg_invalid = True
    else:
        service_arg_invalid = True

    if service_arg_invalid:
        LOGGER.warning(f"Passed service argument might be invalid, "
                       f"setting to {CoreServiceList.SERVICE_17}")
        service_value = CoreServiceList.SERVICE_17
    update_global(CoreGlobalIds.CURRENT_SERVICE, service_value)

def get_default_service_op_code_dict() -> ServiceOpCodeDictT:
    global SERVICE_OP_CODE_DICT
    if SERVICE_OP_CODE_DICT == dict():
        service_op_code_dict = dict()
        service_2_tuple = ("PUS Service 2 Raw CMD", None)
        service_3_tuple = ("PUS Service 3 Housekeeping", None)
        op_code_dict_srv_5 = {
            "0": ("Event Test", {OpCodeDictKeys.TIMEOUT: 2.0}),
        }
        service_5_tuple = ("PUS Service 5 Event", op_code_dict_srv_5)
        service_8_tuple = ("PUS Service 8 Functional CMD", None)
        service_9_tuple = ("PUS Service 9 Time", None)
        service_11_tuple = ("PUS Service 11 TC Scheduling", None)
        op_code_dict_srv_17 = {
            "0": ("Ping Test", {OpCodeDictKeys.TIMEOUT: 2.2}),
        }
        service_17_tuple = ("PUS Service 17 Test", op_code_dict_srv_17)
        service_20_tuple = ("PUS Service 20 Parameters", None)
        service_23_tuple = ("PUS Service 23 File MGMT", None)

        service_op_code_dict[CoreServiceList.SERVICE_2.value] = service_2_tuple
        service_op_code_dict[CoreServiceList.SERVICE_3.value] = service_3_tuple
        service_op_code_dict[CoreServiceList.SERVICE_5.value] = service_5_tuple
        service_op_code_dict[CoreServiceList.SERVICE_17.value] = service_17_tuple
        service_op_code_dict[CoreServiceList.SERVICE_20.value] = service_20_tuple
        service_op_code_dict[CoreServiceList.SERVICE_23.value] = service_23_tuple
        SERVICE_OP_CODE_DICT = service_op_code_dict
    return service_op_code_dict
